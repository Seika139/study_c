# 1 章まずは基礎から

## 1-1 C はどんな言語なのか

### 1-1-1 C の生い立ち

かつて UNIX はアセンブリ言語で書かれていた。
アセンブリ言語は移植やメンテナンスが大変なので、現場の人間が自分の用途のために都合よく作った言語が C 言語である。
その後も必要に応じて行き当たりばったりで機能拡張を繰り返してきた。
もともと**C はアセンブラの代替品だった**。

#### Tips (アセンブラ、アセンブリ言語)

CPU が実行できるのは機械語(0 と 1)
アセンブリ言語を機械語になおすこと「アセンブル」、自動でアセンブルするプログラムを「アセンブラ」という。

### 1-1-2 文法上の不備・不統一

- コンパイラの警告レベルはなるべくあげよう
- コンパイラの警告を無視するな

### 1-1-3 C のバイブル - K&R

後述の ANSI 規格が制定されるまで、C の文法のバイブルだった。
この本は予想を超えて売れ、もともと自分たちだけが使う予定だった言語が世界中で使われるように**なってしまった**。

### 1-1-4 ANSI C 以前の C

現在の C で式数がない関数のプロトタイプ宣言をするときに

```c
void func(void);
```

と書く必要があるのは古い C との互換性を保つためである。

### 1-1-5 ANSI C (C89/90)

ANSI (America National Standards Institute / 米国規格協会) が 1989 年に C 言語の標準仕様案を採択した →`ANSI C`。
ANSI C はその翌年に ISO が採択し `ISO=IEC 9899:1990` という規格になった。
このバージョンの C を `C89` や `C90` という。本書では `ANSI C` と呼ぶ。

### 1-1-6 C95

ワイド文字を扱ったり、ワイド文字とマルチバイト文字との相互変換を行うための関数群が追加。

### 1-1-7 C99

多くの機能が追加される。
C99 は JIS 規格にもなっている。

<div style="page-break-before:always"></div>

### 1-1-8 C11

2021 年現在で最新の規格。

### C の規格年表

|  年  |             規格名             |
| :--: | :----------------------------: |
| 1978 |              K&R               |
| 1988 |   K&R 第 2 版 (ANSI C 準拠)    |
| 1989 |      ANSI C の規格が制定       |
| 1995 | C95 (正式名 ISO/IEC 9899:1990) |
| 1995 | C99 (正式名 ISO/IEC 9899:1999) |
| 2011 | C11 (正式名 ISO/IEC 9899:2011) |

### 1-1-9 C の理念

ANSI C の資料に付属する「Rationale(理論的根拠)」という文書より。

- プログラマーを信じなさい
- プログラマーが、理由があって何かをしようとしているとき、それを妨げてはならない
- 言語を小さく、シンプルに保とう
- ある 1 つの操作のためには、たった 1 つの方法だけを提供しよう
- たとえ移植性が保たれなくても高速にしよう

つまり、C 言語は **プログラマーが全能である** ことを前提として作られている。

したがって、以下のような対立構造が生まれる。

|                   **重視**                   |                       **軽視**                       |
| :------------------------------------------: | :--------------------------------------------------: |
|     いかにコンパイラを簡単に実装できるか     |     プログラマがいかに簡単にプログラムをかけるか     |
| いかに高速な実行コードを吐くソースが書けるか | いかにコンパイラで最適化して高速な実行コードを吐くか |

C は UNIX を作ったエキスパートたちが「自分たちのために」作った言語なので**安全性は無視**されている。

> **結論**
>
> - OS がプログラムを止めてくれるのは幸運なケース
> - 厄介なのは OS が気づかない「ちょっとした」領域破壊

### 1-1-10 C 言語の本体とは

C はちょっとでも複雑な機能は外部ライブラリに任せている。(`printf()` もそう)

### 1-1-11 C は、スカラしか扱えない言語だった

- スカラ(scalar) : char, int, double, 列挙型などの算術型とポインタのこと
- 集成体型(aggregate) : 配列、構造体、共用体のようにスカラをいくつか組み合わせたもの

初期の C では **一度に扱えるのはスカラだけだった**。

<div style="page-break-before:always"></div>

## 1-2 メモリとアドレス

### 1-2-1 メモリとアドレス

いまどきのコンピュータは 16 ギガバイトのメモリを搭載していたりするが、
これは 1 バイト(8 ビット)を表現できるメモリが 160 億個並んでいるということである。

この膨大なメモリには 0 から順に「アドレス」という番地が 1 バイトごとに振られている。

32bit の PC は 4GB 分のアドレスしか表現できない。

### 1-2-2 メモリと変数

char や short、int などの型によってメモリ上で占めるバイト数が異なる。
これを確認するには `sizeof()` 演算子を使う。

```c
#include <stdio.h>

int main(void)
{
    printf("_Bool..%d\n", (int)sizeof(_Bool)); // C99以降
    printf("char..%d\n", (int)sizeof(char));
    printf("short..%d\n", (int)sizeof(short));
    printf("int..%d\n", (int)sizeof(int));
    printf("long..%d\n", (int)sizeof(long));
    printf("long long..%d\n", (int)sizeof(long long)); // C99以降
    printf("float..%d\n", (int)sizeof(float));
    printf("double..%d\n", (int)sizeof(double));
}
```

例えば私の手元では以下のような実行結果になった。

```console
_Bool..1
char..1
short..2
int..4
long..8
long long..8
float..4
double..8
```

これは人によって違うが、`sizeof()` 演算子は `sizeof(char)` を 1 とした時のサイズを表すので、
`sizeof(char)`は必ず 1 になる。

### 1-2-3 メモリとプログラムの実行

コンパイルされた実行形式(機械言語のプログラム)は HDD や SSD に保管されるが、いざ実行するときにはメモリに格納される。
プログラムを順次実行するとき「現在どのアドレスの機械語命令を実行しているか」を示すカウンタが必要。これを**プログラムカウンタ**という。
プログラムカウンタは命令を実行するごとに増加するが、条件分岐やループがあれば一気に飛んだり戻ったりする。

プログラムで変数の値を参照したり、変数に値を格納する際、CPU は変数の格納されたアドレスのメモリに対して読み書きを行う。
なお、CPU の内部には**レジスタ**と呼ばれる機械語における変数のようなものがある。
レジスタは主記憶(メモリ)よりもずっと高速にアクセスできる代わり数が非常に少ないので、アクセス頻度が高い変数をレジスタに割り当てたりする。
プログラムカウンタもレジスタの 1 つ。

<div style="page-break-before:always"></div>

## 1-3 ポインタについて

### 1-3-1 そもそも、悪名高いポインタとは何か

K&R より

> ポインタは、他の変数のアドレスを内容とする変数であり、C では頻繁に使用される。

ポインタが「変数」であるかのように書いてあるが、実際には必ずしもそうではない。

#### point

まず、「ポインタ型」がある。つまり、ポインタ型の変数もあれば、ポインタ型の値もある。

### 1-3-2 ポインタに触れてみよう

```c
#include <stdio.h>

int main(void)
{
    int alpha = 5;
    int beta = 10;
    int *alpha_p;

    // それぞれの変数のアドレスを表示する
    printf("&alpha   (alphaのアドレス)   .. %p\n", (void *)&alpha);
    printf("&beta    (betaのアドレス)    .. %p\n", (void *)&beta);
    printf("&alpha_p (alpha_pのアドレス) .. %p\n", (void *)&alpha_p);

    // ポインタ変数alpha_pにalphaのアドレスを代入する
    alpha_p = &alpha;
    printf("\nalpha    (alpha_pの値、つまり、alphaのアドレス)             .. %p\n", (void *)alpha_p);

    // alpha_pを経由してalphaの値を表示する
    printf("*alpha_p (alpha_pが指すオブジェクトの値、つまり、alphaの値) .. %d\n", *alpha_p);

    // alpha_pを経由してalphaの値を変更する
    *alpha_p = 15;
    printf("\nalpha (alphaの値) .. %d\n", alpha);
}
```

私の環境では実行結果は以下のようになった。

```console
&alpha   (alphaのアドレス)   .. 0x7ffeea19f2bc
&beta    (betaのアドレス)    .. 0x7ffeea19f2b8
&alpha_p (alpha_pのアドレス) .. 0x7ffeea19f2b0

alpha    (alpha_pの値、つまり、alphaのアドレス)           .. 0x7ffeea19f2bc
*alpha_p (alpha_pが指すオブジェクトの値、つまり、alphaの値) .. 5

alpha (alphaの値) .. 15
```

元の本に

> 変数は、宣言順にメモリに格納されるとは限らない

と書いてあるように、私の環境では逆順になっている。

また、7 行目の

```c
int *alpha_p;
```

は、 `alpha_p` という名前で、「int へのポインタ」型の変数を宣言している。

ポインタの値を `printf()` で表示する時は `%p` を使う。

15 行目ではポインタ変数 `alpha_p` に `alpha` のアドレスを代入している。

19 行目、では**間接演算子**である `*` をつかっている。
ポインタに`*`をつけるとそれは「ポインタが指す先のもの」を表す。
つまりここでは `*alpha` が `alpha` と同義になる。
したがって、22 行目は `alpha = 15;` と同じことをしている。

10~12 行目の `(void *)` はポインタを「どんなデータ型でも構わず指せるポインタ型」である `void*` という型にキャストしている。

#### point

- 変数に `&` 演算子を適用すると、その変数のアドレスが取得できる。このアドレスのことを、その変数へのポインタという。
- ポインタ変数が別の変数へのポインタを保持しているとき「`alpha_p` は `alpha` を指している」という。
- ポインタに `*` 演算子を適用すると、そのポインタの指している先のものを表す。つまり、`*alpha_p` と `alpha` が同義になる。

### 1-3-3 アドレス演算子、間接演算子、添字演算子

`+` は `a + b` のように 2 つのオペランドを対象に取るので「2 項演算子」という。
それに対して、`&` や `*` は 1 つのオペランドを対象に取るので「単項演算子」という。
添字演算子 `[]` は配列と添字の 2 つのオペランドを対象に取るので 2 項演算子と呼びたいところだが、規格では「高知演算子」というくくりになっている。
間接演算子 `*` や添字演算子 `[]` は

```c
*alpha_p = 15;
```

のように演算子の結果の式に代入できたりする。これを、演算子結果の式が**左辺値**(lvalue)である、といったりする。

厄介なのは宣言における `*` や `[]` である。

```c
int *alpha_p;
```

のように、宣言で現れる `*` や `[]` は「区切り子」と呼ばれ、式で現れる `*` や `[]` とは **別物** である。

### 【補足】C 言語の宣言のクセ

C の変数宣言は必ずしも `型 変数名;` とはならない。

```c
int *p; // intへのポインタ型の変数 p

int a[10]; // 大きさが10のintの配列
```

結論 C において宣言の構文は「どうしようもないほど不自然で、奇ッ怪で、変態的」だから自然に読む努力をするのは無駄。

### 1-3-4 ポインタとアドレスの奇妙な関係

あとでかけたら書く

### 1-3-5 ポインタ演算

```c
#include <stdio.h>

int main(void)
{
    int alpha;
    int *alpha_p;

    // alpha_pにalphaへのポインタを設定
    alpha_p = &alpha;

    // alpha_pの値を表示
    printf("alpha_p .. %p\n", (void *)alpha_p);

    // alpha_pに1を加算
    alpha_p++;
    printf("alpha_p .. %p\n", (void *)alpha_p);

    // alpha_pに3を加算
    alpha_p += 3;
    printf("alpha_p .. %p\n", (void *)alpha_p);

    // intのバイト数を表示
    printf("%lu\n", sizeof(int));
}
```

これを実行すると私の環境では以下のようになった。

```console
alpha_p .. 0x7ffee26af28c
alpha_p .. 0x7ffee26af290 # 4増えた
alpha_p .. 0x7ffee26af29c # 12増えた
4
```

C ではポインタに 1 を加算すると**ポインタが指す型のサイズだけ増加する**。
int のサイズが 4 であるため、1 加算すると 4 バイト増えたのである。

### 1-3-6 ヌルポインタとは何か？

**ヌルポインタ (null pointer)** とは、何も指していないことが保証されているポインタのこと。
ヌルポインタを表す定数値として、通常はマクロ NULL を使用する。

#### この項の結論

- ヌルポインタを示すには、 NULL を使う
- ナル文字には `\0` を使う

### 1-3-7 実践 - 関数から複数の値を返してもらう

#### C 言語でポインタを使う理由 3 選

1. 関数から複数の値を返してもらう
2. 配列をアクセスする
3. 連結リストや木構造のようなデータ構造を実現する

の中の 1 つ目を実践する。

```c
#include <stdio.h>

void get_xy(double *x_p, double *y_p)
{
    // 仮引数の値とアドレスを表示する
    printf("x_p  .. %p, y_p  .. %p\n", (void *)x_p, (void *)y_p);
    printf("&x_p .. %p, &y_p .. %p\n\n", (void *)&x_p, (void *)&y_p);

    // 引数で渡されたアドレスの値を格納する
    *x_p = 2.0;
    *y_p = 3.0;
}

int main(void)
{
    double x;
    double y;

    // x,yのアドレスを表示する
    printf("&x .. %p, &y .. %p\n\n", (void *)&x, (void *)&y);

    // 引数として変数x,yのアドレスを渡し、値を格納してもらう
    get_xy(&x, &y);

    // x,yの値を表示する
    printf("&x .. %f, &y .. %f\n", x, y);

    return 0;
}
```

C には参照渡しがない。
したがって、以下のように get_xy の引数をポインタではなく double 型の値にすると main 側で x,y の値は書き換えられないのである。

```c
#include <stdio.h>

void get_xy(double x, double y)
{
    // 仮引数の値とアドレスを表示する
    printf("x  .. %p, y  .. %p\n", (void *)x, (void *)y);
    printf("&x .. %p, &y .. %p\n\n", (void *)&x, (void *)&y);

    // 引数で渡されたアドレスの値を格納する
    x = 2.0;
    y = 3.0;
}

int main(void)
{
    double x = 5.0;
    double y = 6.0;

    // x,yのアドレスを表示する
    printf("&x .. %p, &y .. %p\n\n", (void *)&x, (void *)&y);

    // 引数として変数x,yのアドレスを渡し、値を格納してもらう
    get_xy(x, y);

    // x,yの値を表示する
    printf("&x .. %f, &y .. %f\n", x, y);

    return 0;
}
```

つまり、C では存在しない参照渡しの代わりとして、**ポインタを値渡し**するのである。

### 【補足】仮引数と実引数

```c
// この x が仮引数
void func(int x)
{
    printf("%d\n",x);
}

int main()
{
    func(5); // この5が実引数
}
```

## 1-4 配列について

### 1-4-1 配列を使う

とりあえずつかってみよう。

```c
#include <stdio.h>

int main(void)
{
    int array[5];
    int i;

    // 配列arrayに値を指定
    for (i = 0; i < 5; i++)
    {
        array[i] = i;
    }

    for (i = 0; i < 5; i++)
    {
        printf("value = %d, ", array[i]);
        printf("address = %p\n", (void *)&array[i]);
    }

    return 0;
}
```

### 1-4-2 配列とポインタの奇妙な関係

```c
#include <stdio.h>

int main(void)
{
    int array[5];
    int i;

    // 配列arrayに値を指定
    for (i = 0; i < 5; i++)
    {
        array[i] = i;
    }

    // その内容を表示(ポインタ版)
    for (int *p = &array[0]; p != &array[5]; p++)
    {
        printf("%d\n", *p);
    }

    return 0;
}
```

`p++` でポインタが `sizeof(int)` の分だけ先に進むのがミソ。

この章の主張は、**こんな奇妙な書き方は辞めてしまおう**ということ。

### 1-4-3 添字演算子[]は、配列とは無関係だ！

配列は「その先頭要素へのポインタ」に読み替えられる。
3 つほどマイナーな例外はあるが、後ろに[]が付くかどうか関係ない。

```c
/* 以下の二つは同じ */
p = &array[0];
p = array;
```

- `p[i]` は `*(p + i)` の簡便記法(シンタックスシュガー)である。
- `i[p]` と書くこともできるが、わかりにくいので書くな。

### 1-4-4 ポインタ演算という妙な機能はなぜあるのか？

古いコンパイラではポインタ演算を駆使することで高速な処理ができたが、現在のコンパイラでは最適化が進んでおり配列とポインタ演算で差が出なくなった。
つまり、C のポインタ演算は開発された当初には必要だった機能である。

### 1-4-5 ポインタ演算なんか使うのはやめてしまおう

多くの入門書でポインタ演算を駆使したコードを「効率が良い」、「C 言語らしい」などと説明しているが、C 言語らしく書くことで読みにくいコードが完成するなら、そのような悪しき慣習は捨てるべきだ。
しかし、既存のコードでポインタ演算を使用したものが存在している以上、ポインタ演算を使ったコードも読めなければならないという悲しい現実もある。

### 1-4-6 関数の引数として配列を渡す(つもり)

英文のテキストファイルを読み込み、1 つずつ単語を取り出す関数を考える。
返り値は単語の文字数として、ファイルを最後まで読んだ時は EOF を返す。

```c
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>

int get_word(char *buf, int buf_size, FILE *fp)
{
    int len;
    int ch;

    // 空白文字を読み飛ばす
    while ((ch = getc(fp)) != EOF && !isalnum(ch))
        ;

    if (ch == EOF)
        return EOF;

    // ここでchには単語の最初の文字が格納されている
    len = 0;
    do
    {
        buf[len] = ch;
        len++;
        if (len >= buf_size)
        {
            // 単語が長すぎるのでエラー
            fprintf(stderr, "word too long\n");
            exit(1);
        }
    } while ((ch = getc(fp)) != EOF && isalnum(ch));

    buf[len] = '\0';
    return len;
}

int main(void)
{
    char buf[256];

    while (get_word(buf, 256, stdin) != EOF)
    {
        printf("\"%s\"\n", buf);
    }

    return 0;
}
```

> 配列を関数の引数として渡したければ、先頭要素へのポインタを渡す。

### 1-4-7 関数の仮引数の宣言の書き方

**関数の仮引数の宣言に限り**配列の宣言はポインタに読み替えられる(シンタックスシュガー)。

つまり、 `int func(int a[])` は `int func(int *a)` とコンパイラにより特別に読み替えられる。

また、 `int func(int a[10])` のように要素数が入っていても無視される。

注意すべきは、 `int a[]` が `int *a` と同じ意味を持つのは唯一このケースだけだということ。

### 【補足】なぜ C は、配列の範囲チェックをしてくれないのか？

C において配列はポインタに読み替えられる上、配列ないの要素を別のポインタ変数で指すこともできる。
また、他の関数に配列を渡す時は配列の先頭要素をポインタとして渡す。
ポインタを多用する想定で作られた言語である以上、配列の範囲チェックをするのは難しかったという経緯がある。

### 1-4-8 C99 の可変長配列 -- VLA

長らく C の配列といえばサイズが固定で、 `malloc()` による動的メモリ確保を行わない限り、ソースファイルにサイズを直接記述する必要があった。
つまり、配列の要素数を変数で宣言することができなかった。

```c
int array[10];
```

ISO C))からは、自動変数(static でないローカル変数)に限り、配列の要素数に変数を入れて宣言ができるようになった。

```C
int array[x];
```

これを**可変長配列**(VLA : Variable Length Array)と呼ぶ。

本書では `malloc()` による配列は**動的配列**と呼ぶことにする。

```c
#include <stdio.h>

int main(void)
{
    int size1;
    int size2;
    int size3;

    printf("input 3 integers > ");
    scanf("%d%d%d", &size1, &size2, &size3);

    // 可変長配列の宣言
    int array1[size1];
    int array2[size2][size3];

    // 適当に値を代入する
    int i;
    for (i = 0; i < size1; i++)
    {
        array1[i] = i;
    }

    int j;
    for (i = 0; i < size2; i++)
    {
        for (j = 0; j < size3; j++)
        {
            array2[i][j] = i * size3 + j;
        }
    }

    // 代入された値を表示する
    for (i = 0; i < size1; i++)
    {
        printf("array1[%d] ... %d\n", i, array1[i]);
    }

    for (i = 0; i < size2; i++)
    {
        for (j = 0; j < size3; j++)
        {
            printf("\t%d", array2[i][j]);
        }
        printf("\n");
    }

    printf("sizeof(array1) .. %zd\n", sizeof(array1));
    printf("sizeof(array2) .. %zd\n", sizeof(array2));
}
```

このように、ISO C99 では実行時に配列のサイズが決まることもある。

ただ、残念ながら VLA は C11 においてオプション機能に格下げされてしまった。
マクロ `__STDC_NO_VLA__` が定義されていたら、その処理系には VLA の機能はない。
