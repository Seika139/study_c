# C 言語ポインタ完全制覇（のまとめ）

## 書籍情報

- [「C 言語 ポインタ完全制覇(第 2 版)」書籍情報](http://kmaebashi.com/seiha2/index.html)

正誤表も載っている。何箇所もミスがあるので見ておくと良い

## 目次

- 前書き（この本を読んで思ったことなど）
- 1 章 : まずは基礎から - 予備知識と復習
- 2 章 : 実験してみよう - C はどうメモリを使うのか
  - 初心者向けに「ぽいんたはアドレスだ」的な観点からの説明
  - アドレスが `printf()` すれば実際に値を目で見て確認できるのでわかりやすい
- 3 章 : C の文法を解き明かす - 結局のところ、どういうことなのか
  - C の文法は首尾一貫しているようで実は多くの例外がある
- 4 章 : 定石集 - 配列とポインタのよくある使い方
  4 章は実践編、「ポインタへのポインタ」についても理解できる
- 5 章 : データ構造 - ポインタの芯の使い方
  - C 言語でデータ構造を構築する際にはポインタと構造体が重要な役目を果たしている
- 6 章 : その他 - 落ち穂拾い
  - 5 章までに拾えなかった事がら

## 前書き

私は C 言語をほとんど書いたことがないレベルの初心者で、3 月に「新・明解 C 言語入門編」を読んだだけです。
そういう理由でまとめかたに不足があったり、間違いがあったりしたらすいません。
今回のまとめは前半の方が気合入っていて後半が尻すぼみになってしまったのは申し訳ないですが、後半の方はコードが直接書かれている部分が多いので、それを観た方が早いと思います。
それから、一通り読んだ感想として「やっぱ C 言語むずい」でした。
結局プログラミング言語は本を読む以上に実際にコードを書くのが上達につながる気がします。
しかし、この本はポインタの複雑さを誤魔化したりせずに丁寧に解説してくれる良書でした。
C 言語をある程度書ける人が読むとより理解が深まる本だと思います。
それでは拙いまとめをお読みください。

<div style="page-break-before:always"></div>

# 1 章まずは基礎から

## 1-1 C はどんな言語なのか

### 1-1-1 C の生い立ち

かつて UNIX はアセンブリ言語で書かれていた。
アセンブリ言語は移植やメンテナンスが大変なので、現場の人間が自分の用途のために都合よく作った言語が C 言語である。
その後も必要に応じて行き当たりばったりで機能拡張を繰り返してきた。
もともと**C はアセンブラの代替品だった**。

#### Tips (アセンブラ、アセンブリ言語)

CPU が実行できるのは機械語(0 と 1)
アセンブリ言語を機械語になおすこと「アセンブル」、自動でアセンブルするプログラムを「アセンブラ」という。

### 1-1-2 文法上の不備・不統一

- コンパイラの警告レベルはなるべくあげよう
- コンパイラの警告を無視するな

### 1-1-3 C のバイブル - K&R

後述の ANSI 規格が制定されるまで、C の文法のバイブルだった。
この本は予想を超えて売れ、もともと自分たちだけが使う予定だった言語が世界中で使われるように**なってしまった**。

### 1-1-4 ANSI C 以前の C

現在の C で式数がない関数のプロトタイプ宣言をするときに

```c
void func(void);
```

と書く必要があるのは古い C との互換性を保つためである。

### 1-1-5 ANSI C (C89/90)

ANSI (America National Standards Institute / 米国規格協会) が 1989 年に C 言語の標準仕様案を採択した →`ANSI C`。
ANSI C はその翌年に ISO が採択し `ISO=IEC 9899:1990` という規格になった。
このバージョンの C を `C89` や `C90` という。本書では `ANSI C` と呼ぶ。

### 1-1-6 C95

ワイド文字を扱ったり、ワイド文字とマルチバイト文字との相互変換を行うための関数群が追加。

### 1-1-7 C99

多くの機能が追加される。
C99 は JIS 規格にもなっている。

<div style="page-break-before:always"></div>

### 1-1-8 C11

2021 年現在で最新の規格。

### C の規格年表

|  年  |             規格名             |
| :--: | :----------------------------: |
| 1978 |              K&R               |
| 1988 |   K&R 第 2 版 (ANSI C 準拠)    |
| 1989 |      ANSI C の規格が制定       |
| 1995 | C95 (正式名 ISO/IEC 9899:1990) |
| 1995 | C99 (正式名 ISO/IEC 9899:1999) |
| 2011 | C11 (正式名 ISO/IEC 9899:2011) |

### 1-1-9 C の理念

ANSI C の資料に付属する「Rationale(理論的根拠)」という文書より。

- プログラマーを信じなさい
- プログラマーが、理由があって何かをしようとしているとき、それを妨げてはならない
- 言語を小さく、シンプルに保とう
- ある 1 つの操作のためには、たった 1 つの方法だけを提供しよう
- たとえ移植性が保たれなくても高速にしよう

つまり、C 言語は **プログラマーが全能である** ことを前提として作られている。

したがって、以下のような対立構造が生まれる。

|                   **重視**                   |                       **軽視**                       |
| :------------------------------------------: | :--------------------------------------------------: |
|     いかにコンパイラを簡単に実装できるか     |     プログラマがいかに簡単にプログラムをかけるか     |
| いかに高速な実行コードを吐くソースが書けるか | いかにコンパイラで最適化して高速な実行コードを吐くか |

C は UNIX を作ったエキスパートたちが「自分たちのために」作った言語なので**安全性は無視**されている。

> **結論**
>
> - OS がプログラムを止めてくれるのは幸運なケース
> - 厄介なのは OS が気づかない「ちょっとした」領域破壊

### 1-1-10 C 言語の本体とは

C はちょっとでも複雑な機能は外部ライブラリに任せている。(`printf()` もそう)

### 1-1-11 C は、スカラしか扱えない言語だった

- スカラ(scalar) : char, int, double, 列挙型などの算術型とポインタのこと
- 集成体型(aggregate) : 配列、構造体、共用体のようにスカラをいくつか組み合わせたもの

初期の C では **一度に扱えるのはスカラだけだった**。

<div style="page-break-before:always"></div>

## 1-2 メモリとアドレス

### 1-2-1 メモリとアドレス

いまどきのコンピュータは 16 ギガバイトのメモリを搭載していたりするが、
これは 1 バイト(8 ビット)を表現できるメモリが 160 億個並んでいるということである。

この膨大なメモリには 0 から順に「アドレス」という番地が 1 バイトごとに振られている。

32bit の PC は 4GB 分のアドレスしか表現できない。

### 1-2-2 メモリと変数

char や short、int などの型によってメモリ上で占めるバイト数が異なる。
これを確認するには `sizeof()` 演算子を使う。

```c
#include <stdio.h>

int main(void)
{
    printf("_Bool..%d\n", (int)sizeof(_Bool)); // C99以降
    printf("char..%d\n", (int)sizeof(char));
    printf("short..%d\n", (int)sizeof(short));
    printf("int..%d\n", (int)sizeof(int));
    printf("long..%d\n", (int)sizeof(long));
    printf("long long..%d\n", (int)sizeof(long long)); // C99以降
    printf("float..%d\n", (int)sizeof(float));
    printf("double..%d\n", (int)sizeof(double));
}
```

例えば私の手元では以下のような実行結果になった。

```console
_Bool..1
char..1
short..2
int..4
long..8
long long..8
float..4
double..8
```

これは人によって違うが、`sizeof()` 演算子は `sizeof(char)` を 1 とした時のサイズを表すので、
`sizeof(char)`は必ず 1 になる。

### 1-2-3 メモリとプログラムの実行

コンパイルされた実行形式(機械言語のプログラム)は HDD や SSD に保管されるが、いざ実行するときにはメモリに格納される。
プログラムを順次実行するとき「現在どのアドレスの機械語命令を実行しているか」を示すカウンタが必要。これを**プログラムカウンタ**という。
プログラムカウンタは命令を実行するごとに増加するが、条件分岐やループがあれば一気に飛んだり戻ったりする。

プログラムで変数の値を参照したり、変数に値を格納する際、CPU は変数の格納されたアドレスのメモリに対して読み書きを行う。
なお、CPU の内部には**レジスタ**と呼ばれる機械語における変数のようなものがある。
レジスタは主記憶(メモリ)よりもずっと高速にアクセスできる代わり数が非常に少ないので、アクセス頻度が高い変数をレジスタに割り当てたりする。
プログラムカウンタもレジスタの 1 つ。

<div style="page-break-before:always"></div>

## 1-3 ポインタについて

### 1-3-1 そもそも、悪名高いポインタとは何か

K&R より

> ポインタは、他の変数のアドレスを内容とする変数であり、C では頻繁に使用される。

ポインタが「変数」であるかのように書いてあるが、実際には必ずしもそうではない。

#### point

まず、「ポインタ型」がある。つまり、ポインタ型の変数もあれば、ポインタ型の値もある。

### 1-3-2 ポインタに触れてみよう

```c
#include <stdio.h>

int main(void)
{
    int alpha = 5;
    int beta = 10;
    int *alpha_p;

    // それぞれの変数のアドレスを表示する
    printf("&alpha   (alphaのアドレス)   .. %p\n", (void *)&alpha);
    printf("&beta    (betaのアドレス)    .. %p\n", (void *)&beta);
    printf("&alpha_p (alpha_pのアドレス) .. %p\n", (void *)&alpha_p);

    // ポインタ変数alpha_pにalphaのアドレスを代入する
    alpha_p = &alpha;
    printf("\nalpha    (alpha_pの値、つまり、alphaのアドレス)             .. %p\n", (void *)alpha_p);

    // alpha_pを経由してalphaの値を表示する
    printf("*alpha_p (alpha_pが指すオブジェクトの値、つまり、alphaの値) .. %d\n", *alpha_p);

    // alpha_pを経由してalphaの値を変更する
    *alpha_p = 15;
    printf("\nalpha (alphaの値) .. %d\n", alpha);
}
```

私の環境では実行結果は以下のようになった。

```console
&alpha   (alphaのアドレス)   .. 0x7ffeea19f2bc
&beta    (betaのアドレス)    .. 0x7ffeea19f2b8
&alpha_p (alpha_pのアドレス) .. 0x7ffeea19f2b0

alpha    (alpha_pの値、つまり、alphaのアドレス)           .. 0x7ffeea19f2bc
*alpha_p (alpha_pが指すオブジェクトの値、つまり、alphaの値) .. 5

alpha (alphaの値) .. 15
```

元の本に

> 変数は、宣言順にメモリに格納されるとは限らない

と書いてあるように、私の環境では逆順になっている。

また、7 行目の

```c
int *alpha_p;
```

は、 `alpha_p` という名前で、「int へのポインタ」型の変数を宣言している。

ポインタの値を `printf()` で表示する時は `%p` を使う。

15 行目ではポインタ変数 `alpha_p` に `alpha` のアドレスを代入している。

19 行目、では**間接演算子**である `*` をつかっている。
ポインタに`*`をつけるとそれは「ポインタが指す先のもの」を表す。
つまりここでは `*alpha` が `alpha` と同義になる。
したがって、22 行目は `alpha = 15;` と同じことをしている。

10~12 行目の `(void *)` はポインタを「どんなデータ型でも構わず指せるポインタ型」である `void*` という型にキャストしている。

#### point

- 変数に `&` 演算子を適用すると、その変数のアドレスが取得できる。このアドレスのことを、その変数へのポインタという。
- ポインタ変数が別の変数へのポインタを保持しているとき「`alpha_p` は `alpha` を指している」という。
- ポインタに `*` 演算子を適用すると、そのポインタの指している先のものを表す。つまり、`*alpha_p` と `alpha` が同義になる。

### 1-3-3 アドレス演算子、間接演算子、添字演算子

`+` は `a + b` のように 2 つのオペランドを対象に取るので「2 項演算子」という。
それに対して、`&` や `*` は 1 つのオペランドを対象に取るので「単項演算子」という。
添字演算子 `[]` は配列と添字の 2 つのオペランドを対象に取るので 2 項演算子と呼びたいところだが、規格では「高知演算子」というくくりになっている。
間接演算子 `*` や添字演算子 `[]` は

```c
*alpha_p = 15;
```

のように演算子の結果の式に代入できたりする。これを、演算子結果の式が**左辺値**(lvalue)である、といったりする。

厄介なのは宣言における `*` や `[]` である。

```c
int *alpha_p;
```

のように、宣言で現れる `*` や `[]` は「区切り子」と呼ばれ、式で現れる `*` や `[]` とは **別物** である。

### 【補足】C 言語の宣言のクセ

C の変数宣言は必ずしも `型 変数名;` とはならない。

```c
int *p; // intへのポインタ型の変数 p

int a[10]; // 大きさが10のintの配列
```

結論 C において宣言の構文は「どうしようもないほど不自然で、奇ッ怪で、変態的」だから自然に読む努力をするのは無駄。

### 1-3-4 ポインタとアドレスの奇妙な関係

あとでかけたら書く

### 1-3-5 ポインタ演算

```c
#include <stdio.h>

int main(void)
{
    int alpha;
    int *alpha_p;

    // alpha_pにalphaへのポインタを設定
    alpha_p = &alpha;

    // alpha_pの値を表示
    printf("alpha_p .. %p\n", (void *)alpha_p);

    // alpha_pに1を加算
    alpha_p++;
    printf("alpha_p .. %p\n", (void *)alpha_p);

    // alpha_pに3を加算
    alpha_p += 3;
    printf("alpha_p .. %p\n", (void *)alpha_p);

    // intのバイト数を表示
    printf("%lu\n", sizeof(int));
}
```

これを実行すると私の環境では以下のようになった。

```console
alpha_p .. 0x7ffee26af28c
alpha_p .. 0x7ffee26af290 # 4増えた
alpha_p .. 0x7ffee26af29c # 12増えた
4
```

C ではポインタに 1 を加算すると**ポインタが指す型のサイズだけ増加する**。
int のサイズが 4 であるため、1 加算すると 4 バイト増えたのである。

### 1-3-6 ヌルポインタとは何か？

**ヌルポインタ (null pointer)** とは、何も指していないことが保証されているポインタのこと。
ヌルポインタを表す定数値として、通常はマクロ NULL を使用する。

#### この項の結論

- ヌルポインタを示すには、 NULL を使う
- ナル文字には `\0` を使う

### 1-3-7 実践 - 関数から複数の値を返してもらう

#### C 言語でポインタを使う理由 3 選

1. 関数から複数の値を返してもらう
2. 配列をアクセスする
3. 連結リストや木構造のようなデータ構造を実現する

の中の 1 つ目を実践する。

```c
#include <stdio.h>

void get_xy(double *x_p, double *y_p)
{
    // 仮引数の値とアドレスを表示する
    printf("x_p  .. %p, y_p  .. %p\n", (void *)x_p, (void *)y_p);
    printf("&x_p .. %p, &y_p .. %p\n\n", (void *)&x_p, (void *)&y_p);

    // 引数で渡されたアドレスの値を格納する
    *x_p = 2.0;
    *y_p = 3.0;
}

int main(void)
{
    double x;
    double y;

    // x,yのアドレスを表示する
    printf("&x .. %p, &y .. %p\n\n", (void *)&x, (void *)&y);

    // 引数として変数x,yのアドレスを渡し、値を格納してもらう
    get_xy(&x, &y);

    // x,yの値を表示する
    printf("&x .. %f, &y .. %f\n", x, y);

    return 0;
}
```

C には参照渡しがない。
したがって、以下のように get_xy の引数をポインタではなく double 型の値にすると main 側で x,y の値は書き換えられないのである。

```c
#include <stdio.h>

void get_xy(double x, double y)
{
    // 仮引数の値とアドレスを表示する
    printf("x  .. %p, y  .. %p\n", (void *)x, (void *)y);
    printf("&x .. %p, &y .. %p\n\n", (void *)&x, (void *)&y);

    // 引数で渡されたアドレスの値を格納する
    x = 2.0;
    y = 3.0;
}

int main(void)
{
    double x = 5.0;
    double y = 6.0;

    // x,yのアドレスを表示する
    printf("&x .. %p, &y .. %p\n\n", (void *)&x, (void *)&y);

    // 引数として変数x,yのアドレスを渡し、値を格納してもらう
    get_xy(x, y);

    // x,yの値を表示する
    printf("&x .. %f, &y .. %f\n", x, y);

    return 0;
}
```

つまり、C では存在しない参照渡しの代わりとして、**ポインタを値渡し**するのである。

### 【補足】仮引数と実引数

```c
// この x が仮引数
void func(int x)
{
    printf("%d\n",x);
}

int main()
{
    func(5); // この5が実引数
}
```

## 1-4 配列について

### 1-4-1 配列を使う

とりあえずつかってみよう。

```c
#include <stdio.h>

int main(void)
{
    int array[5];
    int i;

    // 配列arrayに値を指定
    for (i = 0; i < 5; i++)
    {
        array[i] = i;
    }

    for (i = 0; i < 5; i++)
    {
        printf("value = %d, ", array[i]);
        printf("address = %p\n", (void *)&array[i]);
    }

    return 0;
}
```

### 1-4-2 配列とポインタの奇妙な関係

```c
#include <stdio.h>

int main(void)
{
    int array[5];
    int i;

    // 配列arrayに値を指定
    for (i = 0; i < 5; i++)
    {
        array[i] = i;
    }

    // その内容を表示(ポインタ版)
    for (int *p = &array[0]; p != &array[5]; p++)
    {
        printf("%d\n", *p);
    }

    return 0;
}
```

`p++` でポインタが `sizeof(int)` の分だけ先に進むのがミソ。

この章の主張は、**こんな奇妙な書き方は辞めてしまおう**ということ。

### 1-4-3 添字演算子[]は、配列とは無関係だ！

配列は「その先頭要素へのポインタ」に読み替えられる。
3 つほどマイナーな例外はあるが、後ろに[]が付くかどうか関係ない。

```c
/* 以下の二つは同じ */
p = &array[0];
p = array;
```

- `p[i]` は `*(p + i)` の簡便記法(シンタックスシュガー)である。
- `i[p]` と書くこともできるが、わかりにくいので書くな。

### 1-4-4 ポインタ演算という妙な機能はなぜあるのか？

古いコンパイラではポインタ演算を駆使することで高速な処理ができたが、現在のコンパイラでは最適化が進んでおり配列とポインタ演算で差が出なくなった。
つまり、C のポインタ演算は開発された当初には必要だった機能である。

### 1-4-5 ポインタ演算なんか使うのはやめてしまおう

多くの入門書でポインタ演算を駆使したコードを「効率が良い」、「C 言語らしい」などと説明しているが、C 言語らしく書くことで読みにくいコードが完成するなら、そのような悪しき慣習は捨てるべきだ。
しかし、既存のコードでポインタ演算を使用したものが存在している以上、ポインタ演算を使ったコードも読めなければならないという悲しい現実もある。

### 1-4-6 関数の引数として配列を渡す(つもり)

英文のテキストファイルを読み込み、1 つずつ単語を取り出す関数を考える。
返り値は単語の文字数として、ファイルを最後まで読んだ時は EOF を返す。

```c
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>

int get_word(char *buf, int buf_size, FILE *fp)
{
    int len;
    int ch;

    // 空白文字を読み飛ばす
    while ((ch = getc(fp)) != EOF && !isalnum(ch))
        ;

    if (ch == EOF)
        return EOF;

    // ここでchには単語の最初の文字が格納されている
    len = 0;
    do
    {
        buf[len] = ch;
        len++;
        if (len >= buf_size)
        {
            // 単語が長すぎるのでエラー
            fprintf(stderr, "word too long\n");
            exit(1);
        }
    } while ((ch = getc(fp)) != EOF && isalnum(ch));

    buf[len] = '\0';
    return len;
}

int main(void)
{
    char buf[256];

    while (get_word(buf, 256, stdin) != EOF)
    {
        printf("\"%s\"\n", buf);
    }

    return 0;
}
```

> 配列を関数の引数として渡したければ、先頭要素へのポインタを渡す。

### 1-4-7 関数の仮引数の宣言の書き方

**関数の仮引数の宣言に限り**配列の宣言はポインタに読み替えられる(シンタックスシュガー)。

つまり、 `int func(int a[])` は `int func(int *a)` とコンパイラにより特別に読み替えられる。

また、 `int func(int a[10])` のように要素数が入っていても無視される。

注意すべきは、 `int a[]` が `int *a` と同じ意味を持つのは唯一このケースだけだということ。

### 【補足】なぜ C は、配列の範囲チェックをしてくれないのか？

C において配列はポインタに読み替えられる上、配列ないの要素を別のポインタ変数で指すこともできる。
また、他の関数に配列を渡す時は配列の先頭要素をポインタとして渡す。
ポインタを多用する想定で作られた言語である以上、配列の範囲チェックをするのは難しかったという経緯がある。

### 1-4-8 C99 の可変長配列 -- VLA

長らく C の配列といえばサイズが固定で、 `malloc()` による動的メモリ確保を行わない限り、ソースファイルにサイズを直接記述する必要があった。
つまり、配列の要素数を変数で宣言することができなかった。

```c
int array[10];
```

ISO C))からは、自動変数(static でないローカル変数)に限り、配列の要素数に変数を入れて宣言ができるようになった。

```C
int array[x];
```

これを**可変長配列**(VLA : Variable Length Array)と呼ぶ。

本書では `malloc()` による配列は**動的配列**と呼ぶことにする。

```c
#include <stdio.h>

int main(void)
{
    int size1;
    int size2;
    int size3;

    printf("input 3 integers > ");
    scanf("%d%d%d", &size1, &size2, &size3);

    // 可変長配列の宣言
    int array1[size1];
    int array2[size2][size3];

    // 適当に値を代入する
    int i;
    for (i = 0; i < size1; i++)
    {
        array1[i] = i;
    }

    int j;
    for (i = 0; i < size2; i++)
    {
        for (j = 0; j < size3; j++)
        {
            array2[i][j] = i * size3 + j;
        }
    }

    // 代入された値を表示する
    for (i = 0; i < size1; i++)
    {
        printf("array1[%d] ... %d\n", i, array1[i]);
    }

    for (i = 0; i < size2; i++)
    {
        for (j = 0; j < size3; j++)
        {
            printf("\t%d", array2[i][j]);
        }
        printf("\n");
    }

    printf("sizeof(array1) .. %zd\n", sizeof(array1));
    printf("sizeof(array2) .. %zd\n", sizeof(array2));
}
```

このように、ISO C99 では実行時に配列のサイズが決まることもある。

ただ、残念ながら VLA は C11 においてオプション機能に格下げされてしまった。
マクロ `__STDC_NO_VLA__` が定義されていたら、その処理系には VLA の機能はない。

<div style="page-break-before:always"></div>

# 2 章\_実験してみよう

## 2-1 仮想アドレス

現在の PC に搭載される OS ではマルチタスク環境を提供しており、複数のプログラム(プロセス)を同時に実行できる。

例えば、Mac ならターミナルと iTerm2 を同時に起動して同じプログラムを実行する。
このとき、同じアドレスが保持する値を表示するプログラムを動かすと、同じアドレスなのに違う値が返ってくる。

つまり、今時の環境ではポインタを `printf()` で表示して見える値は物理的なメモリのアドレスそのものではない。
今時の PC 環境ならアプリケーションプログラムには、**プロセスごとに独立した**「仮想アドレス空間」が与えられる。
これは C 言語とは関係なく OS と CPU が連携して行う仕事である。
だから、未熟なプログラマが意図しない領域に書き込むようなバグを仕込んでも他のプロセスに迷惑がかかることはないのである。

> 今時の環境なら、アプリケーションプログラムに見えるのは、仮想アドレス空間だ。

## 2-2 C のメモリの使い方

### 2-2-1 C における変数の種類

C の変数は **スコープ**(scope : 有効範囲)と**記憶域期間**(storage duration)という 2 つの軸で分類することができる。

### スコープ

1. グローバル変数

関数の外側で定義した変数はデフォルトでグローバル変数になる。
プログラムを複数のソースファイルに分けて分割コンパイルする場合、グローバル変数は宣言さえしていれば別のソースファイルからでも参照できる。

2. ファイル内 static 変数

グローバル変数のように関数の外側で定義した変数でも、 static をつけるとスコープはそのソースファイル内に限定される。

3. ローカル変数

関数の中で宣言した変数のこと。ローカル変数は宣言を含むブロック( `{}` で囲まれた内側の範囲 )の中でだけ参照することができる。

ローカル変数は基本的に関数の先頭で定義するが、ブロックの頭でも宣言できる。
また、C99 からはブロックの途中でもローカル変数を宣言できるようになった。

### 記憶域期間

1. 静的記憶域期間(static storage duration)

グローバル変数、ファイル内 static 変数、static 指定をつけたローカル変数は**静的記憶域期間**をもつ。
これらの変数を総称して**静的変数**と呼ぶことがある。
これらの変数は、プログラムの開始から終了までの寿命を持ち、メモリの同一アドレス上に存在し続ける。

2. 自動記憶域期間(auto storage duration)

static 指定のないローカル変数は**自動記憶域期間**をもつ。
このような変数を**自動変数**と呼ぶ。
自動記憶域期間を持つ変数はそのブロックに入ると同時に領域が確保され、ブロックを抜けると解放される。
これには通常**スタック**というしくみが使われる。(スタックについては後述)

また、変数ではないが `malloc()` を使用して動的なメモリ確保を行うことができる。
`malloc()` で確保した領域は `free()` で解放するまでの寿命を持つ。

### 2-2-2 アドレスを表示させてみよう

```c
#include <stdio.h>
#include <stdlib.h>

int global_variable;
static int file_static_variable;

void func1(void)
{
    int func1_variable;
    static int local_static_variable;

    printf("&func1_variable .. %p\n", (void *)&func1_variable);
    printf("&local_static_variable .. %p\n", (void *)&local_static_variable);
}

void func2(void)
{
    int func2_variable;
    printf("&func1_variable .. %p\n", (void *)&func2_variable);
}

int main(void)
{
    int *p;

    // 関数へのポインタの表示
    printf("func1 .. %p\n", (void *)func1);
    printf("func2 .. %p\n", (void *)func2);

    // 文字列リテラルのアドレス表示
    printf("string literal .. %p\n", (void *)"abc");

    // グローバル変数のアドレス表示
    printf("&global_variable .. %p\n", (void *)&global_variable);

    // ファイル内static変数のアドレス表示
    printf("&file_static_variable .. %p\n", (void *)&file_static_variable);

    // ローカル変数の表示
    func1();
    func2();

    // malloc()により確保した領域のアドレス
    p = malloc(sizeof(int));
    printf("malloc address .. %p\n", (void *)p);

    return 0;
}
```

上記のコードを実行した結果

| func1                  | 0x105914da0    |
| :--------------------- | :------------- |
| func2                  | 0x105914de0    |
| string literal         | 0x105914f69    |
| &global_variable       | 0x105916020    |
| &file_static_variable  | 0x10591601c    |
| &func1_variable        | 0x7ffeea2eb25c |
| &local_static_variable | 0x105916018    |
| &func2_variable        | 0x7ffeea2eb25c |
| malloc address         | 0x7f996fc05970 |

自動変数だけが大きく離れた位置に割り当てられていることがわかる。

<div style="page-break-before:always"></div>

## 2-3 関数と文字列リテラル

### 2-3-1 書き込み禁止領域

関数（プログラム）本体と文字列リテラルは隣接したアドレスに配置される。
これは、関数本体と文字列リテラルをまとめて 1 つの**書き込み禁止領域**に配置するため。

### 2-3-2 関数へのポインタ

関数へのポインタを格納するポインタの宣言は変態的

```c
int func (double d);  // プロトタイプの関数

int (*func_p)(double); // 関数へのポインタ
```

サンプルプログラム

```c
#include <stdio.h>

/* 引数に1.0を足して表示する関数 */
void func1(double d)
{
    printf("func1: d + 1.0 = %f\n", d + 1.0);
}

/* 引数に2.0を足して表示する関数 */
void func2(double d)
{
    printf("func2: d + 2.0 = %f\n", d + 2.0);
}

int main(void)
{
    void (*func_p)(double);

    func_p = func1;
    func_p(1.0);

    func_p = func2;
    func_p(1.0);

    return 0;
}
```

```console
# 実行結果
func1: d + 1.0 = 2.000000
func2: d + 2.0 = 3.000000
```

「関数へのポインタ」を変数に格納するテクニックは以下のようなケースで使用する。

1. GUI のボタンを表示するときに「そのボタンが表示されたら呼び出される関数」をボタンに覚えておいてもらう。
2. 複雑な処理をライブラリするが、処理の一部をカスタマイズしたい場合、たとえばソートのプログラムについて比較処理だけを外部から与えるようにする。
3. 「関数へのポインタの配列」により処理を振り分ける。

## 2-4 静的変数

### 2-4-1 静的変数とは

静的変数はプログラムの開始から終了まで存在し続ける。よって（仮想）アドレス上で固有の領域を占有する。

### 2-4-2 分割コンパイルとリンク

C では、複数のソースファイルによりプログラムを構成し、それぞれ別々にコンパイルしてから結合することができる。

static 指定のない関数とグローバル変数については **名前が同じであれば** ソースファイルを跨いでも同じものとして扱われる。
この作業を行うのが **リンカ** と呼ばれるプログラムである。

リンカに名前を結合してもらうために、各オブジェクトファイルは **シンボルテーブル** という表を備えていることが多い。

## 2-5 自動変数(スタック)

### 2-5-1 領域の「使い回し」

> 自動変数の領域は、関数を抜けたら別の関数呼び出しで使いまわされる。
> 自動変数のアドレスは関数の呼び出しにより変動し、一定とは限らない。

### 2-5-2 関数呼び出しで何が起きるか？

> C では通常、自動変数はスタックに確保される。

main の内部で呼び出した関数、それがさらに呼びだした関数、はどんどん小さい方にアドレスを積み上げていく。
これが 2-2-2 で自動変数だけが大きく離れた位置に割り当てられている所以である。

### 2-5-3 自動変数をどのように参照するのか

アセンブリ言語を用いてローカル変数がベースポインタからのオフセットで参照されていることを解説している。

### 2-5-4 典型的なセキュリティホール -- バッファオーバーフロー脆弱性

配列の範囲を大きく超えて破壊すると、その関数の復帰情報まで破壊してしまい、その関数から戻ることができなくなる。
復帰情報を書き換えられるということは、悪意のある攻撃者が設定した任意のリターンアドレスから再開されるので、任意のプログラムを実行できてしまう。
これを **バッファオーバーフロー脆弱性** という。

### 2-5-5 可変長引数

C では可変長の引数を取る関数を作ることができる。例として `printf()` があげられる。

```c
printf("%d, %s\n", 100, "str");
```

が参照する領域は小さい方から以下のように並んでいる。

- printf のローカル変数
- 復帰情報、リターンアドレスなど
- 第一引数（`%d, %s\n`）
- 第二引数（`100`）
- 第三引数（`str`）

printf のローカル変数から見て第一引数が常に同じ位置にあるようにするために、引数は後ろから順にスタックに積み上げられていく。

 <!-- 中略  -->

可変長引数の関数ではプロトタイプ宣言による引数の型のチェックが効かないなど、デバッグが難しくなるので可変長引数は、そうしないとソースが描きにくくてどうしようもない場合にのみ使うようにしよう。

<!-- tips は略 -->

### 2-5-6 再起呼び出し

C では通常、自動変数の領域をスタックに確保する。これは領域を使いまわしてメモリを確保する他に、**再起呼び出し**を可能にするという重要な意味がある。
再帰呼び出しの例でフィボナッチ数列がよくあるが実用的じゃないので、ここでは順列の数え上げ（3 連単の買い方）を再起呼び出しを用いて実装する。

```c
#include <stdio.h>

// nの最大数
#define N_MAX (100)

// 数字を使用したら、その添字の要素を1にする
int used_flag[N_MAX + 1];

int result[N_MAX];
int n;
int r;

void print_result(void)
{
    int i;
    for (i = 0; i < r; i++)
    {
        printf("%d ", result[i]);
    }
    printf("\n");
}

void permutation(int nth)
{
    int i;
    if (nth == r)
    {
        print_result();
        return;
    }

    for (i = 1; i <= n; i++)
    {
        if (used_flag[i] == 0)
        {
            result[nth] = i;
            used_flag[i] = 1;
            permutation(nth + 1);
            used_flag[i] = 0;
        }
    }
}

int main(int argc, char **argv)
{
    sscanf(argv[1], "%d", &n);
    sscanf(argv[2], "%d", &r);
    permutation(0);

    return 0;
}
```

### 2-5-7 C99 の可変長配列(VLA)におけるスタック

自動変数に限り配列を可変長にできる。なぜなら自動変数はスタックに確保されるから。

<!-- 略 -->

## 2-6 malloc()による動的な領域確保（ヒープ）

### 2-6-1 malloc の基礎

C では `malloc()` を使って動的に領域を確保できる。
`malloc()` は引数で指定したサイズのメモリの塊を確保して、その先頭へのポインタを返す関数である。

```c
p = malloc(size);
```

メモリ確保に失敗した場合（メモリが足りない場合）、`malloc()`は`NULL`を返す。
`malloc()`で確保した領域は使い終わったら `free()` により解放する。

```c
free(p);
```

このように、動的にメモリを割り当てて任意の順序で解放できる記憶領域のことを**ヒープ**と呼ぶ。

#### malloc()の主な使用例

1. 構造体を動的に確保する <!--説明は省略  連結リスト-->
2. 実行時までサイズがわからない配列を確保する <!-- 説明は省略 動的配列 -->

### 2-6-2 malloc()は「システムコール」か？

ちょっと脱線した話題。

> **システムコール**
>
> OS に何かしてもらおうとするよう要求する特別な関数群。

例えば `printf()` は最終的には `write()` というシステムコールを呼び出す。

`malloc()` は標準他ライブラリの関数ではあるが、システムコールではない。

### 2-6-3 malloc()で何が起きるのか？

<!-- 大きく省略 -->

malloc()の動作原理について知識を持ち合わせていないとデバッグができなかったり、効率の悪いプログラムを書いてしまう。

> malloc()は魔法の関数ではない。

### 2-6-4 free()したあと、その領域はどうなるのか？

free()したからといって、**その領域が即座に OS に返されるわけではない**。

ポインタ A とポインタ B が同じ領域を参照していて、
ポインタ A 側から`free()`したとしても、しばらくはポインタ B 側から以前と同じ値を見ることができる。
どこか別のところで `malloc()` が実行されてこの領域が割り当てられて初めて内容が壊れる。

### 2-6-5 フラグメンテーション

ランダムな順序でいろいろなサイズの領域の確保、開放を繰り返すと、メモリが分断されて細かい空きブロックができることになる。
このような領域は **事実上使用できない**。
このような現象を **フラグメンテーション** という。
C ではアプリケーションプログラムに仮想アドレスを直接渡しているため、ライブラリ側から勝手にブロックを移動させて空き領域を詰めることはできない。

### 2-6-6 malloc()以外の動的メモリ確保関数

#### calloc()

```c
#include <stdlib.h>
void *calloc(size_t nmemb, size_t size);
```

`calloc()` は `malloc()` と同じ方法で、 `nmbmb * size` だけの領域を確保し、その領域をゼロクリアして返す。

<!-- 以下略 -->

#### realloc()

すでに `malloc()` で割り当てている領域のサイズを変更するための関数。

```c
#include <stdlib.h>
void *realloc(void *ptr, size_t size);
```

`realloc()` は `ptr` の指す領域サイズを `size` に変更し、新しい領域へのポインタを返す。

<!-- 略 -->

> realloc() は使い方に気をつけよう。

<div style="page-break-before:always"></div>

## 2-7 アラインメント

<!-- 眠いので略 -->

手作業でパディングを入れても移植性を高めることにはならない。

## 2-8 バイトオーダー

<!-- 詳しい話は略 -->

> 整数にしろ浮動小数点にしろ、メモリ上での表示形式は環境によってバラバラ

## 2-9 言語仕様と実装について

-- ごめんなさい、ここまでの内容はかなりウソです

C は確かに低級言語かもしれないが、高級言語らしく使おうと思えば結構使える。

<!-- 2章終わり -->

<div style="page-break-before:always"></div>

# 3 章 C の文法を解き明かす

## 3-1 C の宣言を解読する

暗号の解読、むずかしい。

## 3-2 C の型モデル

### 3-2-1 基本型と派生型

「◯ 型のポインタへの配列への関数へのポインタへの…」とすることで無限に型を生み出せる。
「int の配列」も「char へのポインタへの配列」も結局は配列という意味で最後の型が重要である。

### 3-2-2 ポインタ型派生

「int のポインタ」も「char へのポインタへのポインタ」などを総称して「T へのポインタ」という。
ポインタに加算をすると T のサイズだけポインタが進む。

```c
int array[3];
int (*array_p)[3];

array_p = &array; // 配列へのポインタ
```

この場合、ポインタに加算をすると `4*3` の 12 バイト進む。

### 3-2-5 C 言語には多次元配列は存在しない

多次元配列のように見えるのは「配列の配列」

### 3-2-6 関数型派生

関数型からはポイント型にしか派生できない。

### 3-2-7 型のサイズを計算する

後述の不完全型以外は型にサイズが決まっている。
どんな型でも `sizeof(型)` とすればサイズがわかる。

### 3-2-8 基本型

char, int, long, float などのこと

### 3-2-9 構造体と共用体

構造体と共用体は文法上は派生型

<div style="page-break-before:always"></div>

### 3-2-10 不完全型

型のサイズが決まらない型の中で、関数型以外のもの。

最終的に C 言語の型は以下の 3 つに分類される。

- オブジェクト型(char、int、配列、ポインタ、構造体など)
- 関数型
- 不完全型

相互に要素を参照する場合の例

```c
typedef struct Woman_tag Woman; // 先にtypedef

typedef struct {
    Woman *wife; // 妻
} Man;

struct Woman_tag {
    Man *husband; // 妻
};
```

最初 Woman_tag が宣言された時点ではサイズがわからないので不完全型。
その後、Woman_tag の内容を定義した時点で不完全型ではなくなる。

## 3-3 式

### 3-3-1 式とデータ型

式は木構造になるよ。

> `a + b * c` は `a` も `b + c` も `a + b * c` も式になる。

そして、**あらゆる式は型を持つ**。

```c
int index = 2;
char str[256];

printf(str);
"0123456"[index];
```

str も文字列リテラルも式の中では「char へのポインタ」になるのでこんな書き方もできる。

### 3-3-2 左辺値とは何か

- 式がどこかの記憶領域を意味しているものを左辺値(lvalue)
- 式が単なる値を意味しているものは右辺値(rvalue)

```c
x = 10;
++y;
```

x と y は左辺値、 10 は右辺値

<div style="page-break-before:always"></div>

### 3-3-3 配列 → ポインタの読み替え

式の中で配列はポインタに読み替えられる。
ただし、以下の場合は例外である。

1. sizeof 演算子のオペランドの場合
   - sizeof ではポインタのサイズではなく、配列のサイズが返されるように読み替えが抑止される
2. &演算子のオペランドの場合
   - 配列に対して `&` をつけるとその配列全体へのポインタを返す
3. 配列初期化時の文字列リテラル
   - 3-5-4 で解説

### 3-3-4 配列とポインタに関係する演算子

#### 間接演算子 `*`

- 単項演算子 `*` を間接演算子という
- `*` はポインタをオペランドとしてとり、指し示すオブジェクトまたは関数を返す
- オブジェクトを返す場合、 `*` の結果は左辺値を持つ
- T 型へのポインタ `t_p` に対して、 `*t_p` の型は T となる。

#### アドレス演算子 `&`

- 単項演算子 `&` をアドレス演算子という
- `&` は左辺値をオペランドとして取る
- T 型のオペランド `t` に対して、 `&t` の型は **T 型へのポインタ** となる

#### 添字演算子 `[]`

- 後置演算子 `[]` を添字演算子という
- `p[i]` は `*(p+i)` のシュガーシンタックスでありそれ以外の意味を持たない

#### アロー演算子 `->`

- `->` 演算子はぽいん t 名を経由して構造体のメンバを参照するのに使う
- `p->hoge` は `(*p).hoge` のシュガーシンタックスである

### 3-3-5 多次元配列

多次元配列「もどき」である `array[i][j]` にアクセスした時に何が起きているか解説している。

## 3-4 続・C の宣言を解読する

### 3-4-1 const 修飾子

const は ANSI C で追加された型修飾子であり、「読み出し専用」であることを意味する。

```c
// src は、charへの、読み出し専用のポインタである
char  * const src;

// src は、「読み出し専用のchar」へのポインタである
char const *src;
const char *src;
```

<div style="page-break-before:always"></div>

### 3-4-2 const をどう使うか？どこまで使えるか？

「const がついたものが指すもの」は読み出し専用だが、「const がついたものが指すもののさらに先にあるもの」に関しては読み出し専用ではない。

### 3-4-3 typedef

typedef はある型に対して別名をつける機能である。たとえば、

```c
typedef char *string;
```

と宣言すると、以後「char へのポインタ」という型に対して「String」という別名をつけることができる。

```c
typedef struct {
    ...
} Hoge;
```

と宣言することで構造体に別名をつけられる。

## 3-5 その他

### 3-5-1 関数の仮引数の宣言(ANSI C 版)

関数の仮引数に配列を渡すことはできない。

```c
void func(int a[])
```

としていても、**関数の仮引数の宣言では**型分類としての配列はポインタに読み替えられるので、

```c
void func(int *a)
```

に自動的に読み替えられる。
仮引数に配列の要素数を書いても無視される。

> **重要**
>
> `int a[]` が `int *a` と同じ意味になるのは、唯一、関数の借り引数の宣言の場合だけである。

### 3-5-2 関数の仮引数の宣言(C99 版)

VLA の一環として「縦横可変の多次元配列」を関数に渡すことができるようになった。

```c
void func(int size1, int size 2, int a[size1][size2])
void func(int size1, int size 2, int a[][size2]) // 配列のサイズは無視される
void func(int size1, int size 2, int (*a)[size2]) // 実態はポインタなのでこのように宣言しても良い
```

### 3-5-3 空の[]について

以下の例ではコンパイラが特別に解釈するため、空の`[]`を書くことができる。

1. 関数の仮引数の宣言

関数の仮引数の宣言において**最外周の配列に限り**、ポインタに読み替えられる。

2. 初期化子により配列のサイズが確定できる場合

以下のように、初期化子により必要な要素数をコンパイラが決定できる場合は、**最外周の配列に限り**、要素数を省略できる。

<div style="page-break-before:always"></div>

```c
int a[] = {1,3,5,7};
char str[] = "abc";
double matrix[][2] = {{0,1},{1,0}};
char *color_name[] = {
    "red",
    "green",
    "blue",
};
```

3. グローバル変数を extern 宣言する場合
4. 構造体のフレキシブル配列メンバ

### 3-5-4 文字列リテラル

`""` で囲まれた文字列のことを「文字列リテラル」という。
文字列リテラルの型は「char の配列」であり、式の中では「char へのポインタ」に読み替えられる。

```c
char *str;
str = "abc";
```

ただし、char の配列を初期化する場合は例外である。

```c
char str[] = "abc";
```

これは下と同義である。

```c
char str[] = {'a', 'b', 'c', '\0'};
```

### 3-5-5 関数のポインタにおける混乱

- 関数は式の中では「関数へのポインタ」に自動的に変換される。ただし、アドレス演算子 `&` のオペランドであるときと、sizeof 演算子のオペランドである時は例外である
- 関数呼び出し演算子`()`は関数ではなく関数へのポインタをオペランドとする

### 3-5-6 キャスト

ある型を強制的に他の型に変換する演算子

```c
(型名)
```

例として整数同士の割り算を小数で表す時に使う。

```c
int a,b;
printf("a/b ... %f\n", (double)a/b);
```

また、ポインタをキャストする時にも使う。

### 3-5-7 練習 - 複雑な宣言を読んでみよう

複雑な宣言を読む練習をしている。

<div style="page-break-before:always"></div>

## 3-6 配列とポインタは別ものだ

### 3-6-1 なぜ混乱してしまうのか

**C において、配列とポインタは別物です**。

### 3-6-2 式の中では

式の中では、配列はその先頭要素のポインタに読み替えられる。

```c
int *p;
int array[10];
p = array;  // pには、array[0]へのポインタが代入される
```

しかし、逆に

```c
array = p;
```

のような書き方はできない。
array は式の中でポインタに書き換えられるが、あくまで `&array[0]` に読み替えられているというだけで、この場合のポインタは**右辺値**であるからだ。

`a + 1 = 10` という代入ができないのは、`a + 1`がそれに対応する記憶領域を持たない右辺値であるから、という理由と同じ。

### 3-6-3 宣言では

配列の宣言がポインタの宣言に読み替えられるのは、唯一、関数の仮引数の宣言の場合のみである。

<div style="page-break-before:always"></div>

# 4 章\_定石集

コードを用いた解説が多めなのでかなり端折ってます。すいません。

## 4-1 基本的な使い方

### 4-1-1 戻り値以外の方法で値を返してもらう

戻り値以外の方法で関数から型 T の値を返したいのなら、「T へのポインタ」を引数で返す。

### 4-1-2 配列を関数の引数として渡す

C では本当は「配列を引数として渡す」ことはできない。
しかし、配列の先頭要素へのポインタを渡すことで、あたかも配列を渡しているかのように扱うことができる。

型 T の配列を引数として渡したいなら「T へのポインタ」を渡せば良い。
ただし、配列の要素数は呼び出され側ではわからないので、必要なら別途渡すこと。

### 4-1-3 動的配列 - malloc()による可変長の配列

型 T の可変長の配列が欲しければ「T へのポインタ」を使い、領域を `malloc()` で動的に確保すれば良い。
ただし、配列の要素数は、別に管理する必要がある。

## 4-2 組み合わせて使う

### 4-2-1 動的配列の配列

コードを書いて使用例を解説している

### 4-2-2 動的配列の動的配列

コードを書いて使用例を解説している

### 4-2-3 コマンド行引数

コマンド行からプログラムを実行する時に、**コマンド行引数**として引数を与えることができる。

### 4-2-4 引数経由でポインタを返してもらう

コードを書いて使用例を解説している

> 例外処理では goto を使うとスッキリ書けることが多い

<div style="page-break-before:always"></div>

### 4-2-5 多次元配列を関数の引数として渡す

`4-1-2` にあったように、「T のポインタ」を渡せば良い

### 4-2-6 多次元配列を関数の引数として渡す(VLA 版)

`array[i][j]` の `j` の最大値を可変にできる。

### 4-2-7 縦横可変の 2 次元配列を malloc()で確保する(C99)

オセロの盤面のような 2 次元配列を、コードを書いて使用例を解説している

### 4-2-8 配列の動的配列

折れ線のつなぐ 2 次元座標の x,y 要素の配列からなる要素数が動的な配列についての宣言のはなし。
次の項につづく

### 4-2-9 変に凝る前に、構造体の使用を考えよう

```c
typedef struct {
    double x;
    double y;
} Point;

typedef struct {
    int npoints;
    Point *point;
} Poliline;
```

とした方が、配列を使うよりスッキリする。

### 4-2-10 可変長構造体(ANSI C 版)

構造体の最後のメンバに限り、ポインタを介さずに、直接、可変長の配列を格納することができる。
このやりかたは ANSI C では反則技とされているが、大抵の環境で使える有効な手段。

### 4-2-11 フレキシブル配列メンバ(C99)

先程のテクニックは C99 で「フレキシブル配列メンバ」として正式に言語仕様で採用される。

<div style="page-break-before:always"></div>

# 5 章\_データ構造

## 5-1 case 1 : 単語の使用頻度を数える

この章では、より一般的なデータ構造を構築する上でのポインタの使い方を解説する。
実際にコードをたくさん書く。

### 5-1-1 例題の仕様について

「単語の出現頻度を数える」プログラム `word_count` を考える。

```console
word_count filename
```

としたら、そのファイルに含まれる英単語をアルファベット順にソートして、各単語順に出現回数をつけて標準出力に出力する。
引数を省略した場合は、標準入力からの入力を処理する。

### 5-1-2 設計

大規模な開発では、プログラムを機能単位で分割することが重要になる。

1. 単語取得部 : 入力ストリームから単語を 1 つずつ取得する
2. 単語管理部 : 単語を管理する
3. メインルーチン : 1 と 2 を統括する

### 5-1-3 配列版

「単語管理部」のデータ構造を配列にした場合の実装

### 5-1-4 連結リスト版

「単語管理部」のデータ構造を連結リストにした場合の実装

### 5-1-5 検索機能の追加

二分検索で単語を検索する。

### 5-1-6 その他のデータ構造

#### 双方向連結リスト

```c
typedef struct Node_tag {
    struct Node_tag *prev; // 前の要素へのポインタ
    struct Node_tag *next; // 次の要素へのポインタ
} Node;
```

双方向連結リストは連結リストの以下の問題を解決できる。

- リストに要素を追加する時、追加する位置の前の要素がわからなければならない
- リストを要素から削除する時、削除する要素の前の要素がわからなければならない
- リストを逆順に辿ることが難しい

しかし、以下のようなデメリットもある。

- 要素ごとにポインタが 2 つ必要なのでメモリを余計に消費する
- 操作しなければならないポインタが多いので、コーディングでバグを入れやすい

#### 木構造

```c
typedef struct Node_tag {
    int n_children; // 子の数
    struct Node_tag **child; // この先に、malloc()で子へのポインタの可変長配列をつなぐ
}
```

#### ハッシュ

典型的なハッシュである「外部連鎖ハッシュ」では**ハッシュテーブル**という配列から、連結リストで要素を保持する。
ある要素が格納されるハッシュテーブルの添字を決めるのがハッシュ関数である。

## 5-2 case2 : ドローツールのデータ構造

筆者が作ったサンプルのドローツールである「X-Draw」のデータ構造だけを考えてヘッダファイルのみ作成する。

- [X-Draw](http://kmaebashi.com/seiha2/xdraw/index.html)

<div style="page-break-before:always"></div>

# 6 章\_その他 - 落ち穂拾い

## 6-1 新しい関数群

ANSI C より後の C ではセキュリティを高めるために境界チェックの機能をつけた関数や、静的な記憶領域を使わないように改善された関数がある。

### 6-1-1 範囲チェックが追加された関数(C11)

C では配列の範囲を超えた書き込みを行うと、バッファオーバーフロー脆弱性というセキュリティホールになりうる。
C11 では `gets` がなくなり、かわりに `gets_s` が用意された。

### 6-1-2 静的な領域を使わないようにした関数(C11)

C11 では `strtok` を廃止し `strtok_s` が用意された。

## 6-2 落とし穴

### 6-2-1 整数拡張

標準入力から 1 文字読み込む関数 `getchar()` の戻り値の型は int である。
C では整数拡張という機能により、int より小さなサイズの型は式の中で片っぱしから int に拡張される。

### 6-2-2 古い C で float 型の引数を使ったら

ANSI C 以前の C では、式の中の float 型は片っぱしから double に変換される。

### 6-2-3 printf() と scanf()

`printf()` のような可変長引数を取る関数においては、可変部の引数についてはプロトタイプ宣言が効かない。
よって、そのような部分については ANSI C 以前の C と同様の変換が入る。つまり整数拡張や float→double の変換が行われる。

### 6-2-4 プロトタイプ宣言の光と闇

- 関数を定義しているソースファイルでは、その関数自体のプロトタイプ宣言を含むヘッダファイルを必ず #include すること。
- 別ファイルで定義された関数を呼ぶ際には、必ずプロトタイプ宣言を含むヘッダファイルを #include すること。

<div style="page-break-before:always"></div>

## 6-3 イディオム

### 6-3-1 構造体宣言

構造体の書き方の派閥についての説明。

### 6-3-2 自己参照構造体

宣言している型と同じ型へのポインタを含む構造体を「自己参照構造体」と呼ぶことがある。
現場で聞いたことがない。

### 6-3-3 構造体の相互参照

タグだけ宣言した場合、そのかたは「不完全型」になる。
不完全型にはポインタを取れない。

### 6-3-4 ~ 6-3-7 は省略

### 6-3-8 char へのポインタの配列の初期化

配列の初期化子の最後の要素の後ろにはコンマをつけてもつけなくても良い

### 6-3-9 ~ 6-3-12 も省略
